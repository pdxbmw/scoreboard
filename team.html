<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team History</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Fredoka', sans-serif; background: #f4f7f6; margin: 0; padding: 0; }
        
        /* Dynamic Header */
        .header {
            background: var(--team-color, #333); color: white; padding: 30px 20px;
            text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.2); position: sticky; top: 0; z-index: 100;
        }

        .header h1 { margin: 10px 0 5px 0; font-size: 2.5rem; }
        .header-content { display: flex; flex-direction: column; align-items: center; justify-content: center; margin: 0 auto; padding-left: 80px; padding-right: 80px; }
        .back-btn { 
            position: absolute; top: 20px; left: 20px; background: rgba(255,255,255,0.2); 
            color: white; border: none; padding: 8px 15px; border-radius: 20px; font-weight: bold; cursor: pointer;
            text-decoration: none; font-size: 1rem;
        }

        /* List of Games */
        .game-list { max-width: 600px; margin: 20px auto; padding: 0 15px; }
        .game-row {
            background: white; border-radius: 15px; padding: 15px; margin-bottom: 12px;
            display: flex; align-items: center; justify-content: space-between;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .game-date { font-size: 0.8rem; color: #888; width: 80px; white-space: nowrap; }
        .opponent { display: flex; align-items: center; justify-content: center; gap: 10px; flex: 1; }
        .opponent img { width: 40px; height: 40px; object-fit: contain; }
        .opponent-name { font-weight: bold; color: #333; }
        .result { font-size: 1.2rem; font-weight: bold; width: 80px; text-align: right; white-space: nowrap; }
        
        .win { color: #2e7d32; } /* Green */
        .loss { color: #c62828; } /* Red */
        .future { color: #555; font-size: 0.9rem; }
    </style>
</head>
<body>

    <div class="header" id="header">
        <a href="index.html" class="back-btn">‚Üê Back</a>
        <div class="header-content">
            <h1 id="teamName">Loading...</h1>
            <div id="teamRecord" style="font-size: 1rem; opacity: 0.9;"></div>
        </div>
    </div>

    <div class="game-list" id="games">
        <p align="center">Fetching full season history...</p>
    </div>

    <script>
        // Parse URL params
        const params = new URLSearchParams(window.location.search);
        let TEAM_ID = params.get('id');
        const COLOR = decodeURIComponent(params.get('color'));
        const NAME = params.get('name');
        const LEAGUE = params.get('league') || 'nba';
        const RETURN_TO = params.get('return');

        // Apply Theme
        document.getElementById('header').style.setProperty('--team-color', COLOR);
        const teamNameEl = document.getElementById('teamName');
        if (teamNameEl) {
            // Insert space between rank token (e.g., #3) and name if missing
            const displayName = NAME || "Team Schedule";
            const spaced = displayName.replace(/^(#\d+)([^\s#]+)/, '$1 $2');
            teamNameEl.innerText = spaced;
        }
        const backBtn = document.querySelector('.back-btn');
        if (backBtn && RETURN_TO) backBtn.setAttribute('href', decodeURIComponent(RETURN_TO));

        let refreshTimer;

        const LEAGUE_META = {
            nba: { sport: 'basketball', slug: 'nba' },
            ncaa_mb: { sport: 'basketball', slug: 'mens-college-basketball' },
            ncaa_wb: { sport: 'basketball', slug: 'womens-college-basketball' }
        };

        async function resolveTeamIdByName(force = false) {
            if (!NAME) return;
            if (TEAM_ID && !force) return;
            const leaguePath = LEAGUE_META[LEAGUE]?.slug ? `${LEAGUE_META[LEAGUE].sport}/${LEAGUE_META[LEAGUE].slug}` : 'basketball/nba';
            const listUrl = `https://site.api.espn.com/apis/site/v2/sports/${leaguePath}/teams`;
            try {
                const res = await fetch(listUrl);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                const teams = data?.sports?.[0]?.leagues?.[0]?.teams || [];
                const norm = (s) => (s || '').toLowerCase().trim();
                const target = norm(NAME);
                const match = teams.find(t => {
                    const info = t.team;
                    return info && (norm(info.displayName) === target || norm(info.shortDisplayName) === target || norm(info.name) === target);
                });
                if (match && match.team?.id) {
                    const newId = match.team.id;
                    if (newId !== TEAM_ID) {
                        TEAM_ID = newId;
                        console.log('Resolved TEAM_ID by name to', TEAM_ID);
                        // keep URL in sync for refresh/back
                        const newParams = new URLSearchParams(window.location.search);
                        newParams.set('id', TEAM_ID);
                        const newUrl = `${window.location.pathname}?${newParams.toString()}`;
                        window.history.replaceState({}, '', newUrl);
                    }
                }
            } catch (e) {
                console.log('Could not resolve team id by name', e);
            }
        }

        async function fetchTeamFromAPI() {
            if (!TEAM_ID) return null;
            const leagueMeta = LEAGUE_META[LEAGUE] || LEAGUE_META.nba;
            const leaguePath = `${leagueMeta.sport}/${leagueMeta.slug}`;
            const base = `https://site.api.espn.com/apis/site/v2/sports/${leaguePath}`;
            try {
                const [teamRes, scheduleRes] = await Promise.all([
                    fetch(`${base}/teams/${TEAM_ID}`),
                    fetch(`${base}/teams/${TEAM_ID}/schedule`)
                ]);
                if (!teamRes.ok || !scheduleRes.ok) throw new Error(`HTTP ${teamRes.status}/${scheduleRes.status}`);
                const teamJson = await teamRes.json();
                const schedJson = await scheduleRes.json();
                const teamRecord = teamJson.team?.record?.items?.[0]?.summary || teamJson.team?.recordSummary || '';
                const events = (schedJson?.team?.events || []).filter(ev => {
                    const comp = ev.competitions?.[0];
                    const hasTeam = comp?.competitors?.some(c => c.team?.id === TEAM_ID);
                    return hasTeam && matchesLeague(ev);
                });
                return { teamRecord, events };
            } catch (e) {
                console.log('API fallback failed:', e);
                return null;
            }
        }

        const formatLocal = (iso) => {
            const d = new Date(iso);
            if (isNaN(d.getTime())) return '';
            const dateStr = `${d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}, ${d.getFullYear()}`;
            const timeStr = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            return { dateStr, timeStr };
        };

        const matchesLeague = (ev) => {
            if (!LEAGUE) return true;

            const normalizeAbbr = (abbr) => (abbr || '').toLowerCase();

            const explicit = ev.league_key || ev.league;
            if (explicit) return explicit === LEAGUE;

            const comp = ev.competitions?.[0];
            const leagueAbbr = normalizeAbbr(comp?.league?.abbreviation || ev.leagues?.[0]?.abbreviation);

            if (!leagueAbbr) {
                // League-aware files already include the league in the path; allow when missing metadata
                return true;
            }

            if (LEAGUE === 'nba') return leagueAbbr === 'nba';
            if (LEAGUE === 'ncaa_mb') return leagueAbbr.includes('college') || leagueAbbr.includes('ncaa') || leagueAbbr === 'ncaab' || leagueAbbr === 'ncb';
            if (LEAGUE === 'ncaa_wb') return leagueAbbr.includes('womens') || leagueAbbr.includes('ncaa') || leagueAbbr === 'ncaaw';

            return false;
        };

        async function loadHistory() {
            if (!TEAM_ID) {
                console.warn('Missing TEAM_ID');
                showNoGames();
                return;
            }
            const leagueMeta = LEAGUE_META[LEAGUE] || LEAGUE_META.nba;
            const leaguePath = `${leagueMeta.sport}/${leagueMeta.slug}`;
            const urlNew = `data/teams/sports/${leagueMeta.sport}/${leagueMeta.slug}/${TEAM_ID}.json`;
            const urlLegacy = `data/teams/${TEAM_ID}.json`;
            console.log('Trying league-aware path:', urlNew);
            
            try {
                let res = await fetch(urlNew);
                console.log('Response (league-aware) status:', res.status);
                if (!res.ok) {
                    console.log('Falling back to legacy path:', urlLegacy);
                    res = await fetch(urlLegacy);
                    console.log('Response (legacy) status:', res.status);
                }
                let events = [];
                let teamRecord = '';

                if (res.ok) {
                    const data = await res.json();
                    console.log('Data keys:', Object.keys(data));
                    const dataLeague = data.league_key || data.league;
                    const leagueMismatch = dataLeague && LEAGUE && dataLeague !== LEAGUE;

                    if (leagueMismatch) {
                        console.log('Local data league mismatch, skipping local events');
                        teamRecord = '';
                    } else {
                        events = (data.events || []).filter(ev => {
                            const comp = ev.competitions?.[0];
                            const hasTeam = comp?.competitors?.some(c => c.team?.id === TEAM_ID);
                            const leagueKey = ev.league_key || ev.league || dataLeague;
                            const matchesLeague = !LEAGUE || !leagueKey ? true : leagueKey === LEAGUE;
                            return hasTeam && matchesLeague;
                        });
                        console.log('Events count:', events.length);
                        teamRecord = data.team?.recordSummary || '';
                        if (!events.length) {
                            teamRecord = '';
                        }
                    }
                } else {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }

                // Fallback to ESPN API if no local data
                if ((!events || events.length === 0) || !teamRecord) {
                    console.log('Local data missing or empty, trying API fallback');
                    const apiData = await fetchTeamFromAPI();
                    if (apiData) {
                        events = apiData.events;
                        teamRecord = apiData.teamRecord || '';
                    }
                }

                const filteredEvents = (events || []).filter(ev => {
                    const comp = ev.competitions?.[0];
                    const hasTeam = comp?.competitors?.some(c => c.team?.id === TEAM_ID);
                    return hasTeam && matchesLeague(ev);
                });

                if (!filteredEvents || filteredEvents.length === 0) {
                    const prevId = TEAM_ID;
                    await resolveTeamIdByName(true);
                    if (TEAM_ID && TEAM_ID !== prevId) {
                        return loadHistory();
                    }
                }

                document.getElementById('teamRecord').innerText = teamRecord || 'Season Record';

                if (!filteredEvents || filteredEvents.length === 0) {
                    showNoGames();
                } else {
                    renderGames(filteredEvents);
                }

                // set up auto-refresh to keep live scores current when we have any events
                if (refreshTimer) clearTimeout(refreshTimer);
                if (filteredEvents && filteredEvents.length) {
                    refreshTimer = setTimeout(loadHistory, 20000);
                }
            } catch(e) {
                console.error('Error loading team data:', e);
                const apiData = await fetchTeamFromAPI();
                if (apiData) {
                    const filteredEvents = (apiData.events || []).filter(ev => {
                        const comp = ev.competitions?.[0];
                        const hasTeam = comp?.competitors?.some(c => c.team?.id === TEAM_ID);
                        return hasTeam && matchesLeague(ev);
                    });
                    document.getElementById('teamRecord').innerText = apiData.teamRecord || 'Season Record';
                    if (!filteredEvents || filteredEvents.length === 0) {
                        showNoGames();
                    } else {
                        renderGames(filteredEvents);
                    }
                } else {
                    showNoGames();
                }
            }
        }

        function showNoGames() {
            const friendlyImg = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='220' height='180' viewBox='0 0 220 180'><rect width='220' height='180' rx='24' ry='24' fill='%23f5f7fb'/><circle cx='110' cy='85' r='52' fill='%23fff' stroke='%23d33' stroke-width='4'/><circle cx='90' cy='78' r='7' fill='%23d33'/><circle cx='130' cy='78' r='7' fill='%23d33'/><path d='M82 112c12-10 44-10 56 0' stroke='%23d33' stroke-width='6' fill='none' stroke-linecap='round'/></svg>";
            document.getElementById('games').innerHTML = `
                <div style='text-align:center; color:#444; font-size:1.05rem; padding:24px;'>
                    <img src="${friendlyImg}" alt="No games" style="width:180px; max-width:80%; display:block; margin:0 auto 10px auto;" />
                    <div style="margin-top:8px; font-weight:800;">No games here</div>
                    <div style="margin-top:4px; font-size:1rem; color:#666;">Try another team.</div>
                </div>`;
        }

        async function getOpponentRecord(opponentId) {
            try {
                console.log(`Fetching record for opponent ${opponentId}`);
                const res = await fetch(`data/teams/${opponentId}.json`);
                if (res.ok) {
                    const data = await res.json();
                    const record = data.team?.recordSummary;
                    console.log(`Opponent ${opponentId} record:`, record);
                    return record || '';
                } else {
                    console.log(`Opponent ${opponentId} file not found (status: ${res.status})`);
                }
            } catch (e) {
                console.log('Could not fetch opponent record for', opponentId, e);
            }
            return '';
        }

        async function renderGames(events) {
            const container = document.getElementById('games');
            container.innerHTML = '';
            
            // Sort events by date (oldest first for chronological order)
            events.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            for (const event of events) {
                const game = event.competitions && event.competitions[0];
                if (!game) {
                    console.warn('No competition data for event:', event);
                    continue;
                }
                
                const opponent = game.competitors && game.competitors.find(c => c.team && c.team.id !== TEAM_ID);
                const myTeam = game.competitors && game.competitors.find(c => c.team && c.team.id === TEAM_ID);
                
                if (!opponent || !myTeam) {
                    console.warn('Missing team data for event:', event);
                    continue;
                }
                
                const { dateStr, timeStr } = formatLocal(event.date);
                
                const div = document.createElement('div');
                div.className = 'game-row';

                let resultHTML = "";
                // Check status at competition level
                const isCompleted = game.status && game.status.type && game.status.type.completed;
                
                if (isCompleted) {
                    const myScore = parseInt(myTeam.score?.value || 0);
                    const opScore = parseInt(opponent.score?.value || 0);
                    const isWin = myScore > opScore;
                    
                    resultHTML = `<span class="result ${isWin ? 'win' : 'loss'}">
                        ${isWin ? 'W' : 'L'} ${myScore}-${opScore}
                    </span>`;
                } else {
                    // Show game time for upcoming games (localized)
                    resultHTML = `<span class="result future">${timeStr}</span>`;
                }

                // Get opponent record from their team data
                const opponentRecord = await getOpponentRecord(opponent.team.id);

                const oppColor = opponent.team?.color ? `#${opponent.team.color}` : '#333';
                const oppName = opponent.team?.displayName || opponent.team?.shortDisplayName || opponent.team?.abbreviation || 'Team';
                
                div.innerHTML = `
                    <span class="game-date">${dateStr}</span>
                    <div class="opponent" onclick="location.href='team.html?id=${opponent.team.id}&color=${encodeURIComponent(oppColor)}&name=${encodeURIComponent(oppName)}'" style="cursor:pointer;">
                        <img src="${opponent.team.logos?.[0]?.href || ''}">
                        <div>
                            <span class="opponent-name">${opponent.team.abbreviation || opponent.team.shortDisplayName || 'Unknown'}</span>
                            ${opponentRecord ? `<div class="record">${opponentRecord}</div>` : ''}
                        </div>
                    </div>
                    ${resultHTML}
                `;
                container.appendChild(div);
            }
        }

        loadHistory();
    </script>
</body>
</html>